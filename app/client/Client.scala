/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.0.1-dev
 * apidoc:0.9.17 http://www.apidoc.me/gilt/gilt-trest/0.0.1-dev/play_2_3_client
 */
package com.gilt.gilt.trest.v0.models {

case class Error(
                  error: String
                  )

case class Sale(
                 sales: Seq[com.gilt.public.api.models.SaleDetail]
                 )

case class User(
                 username: String,
                 email: String
                 )

case class UserForm(
                     username: String
                     )

}

package com.gilt.gilt.trest.v0.models {

package object json {
  import play.api.libs.json.__
  import play.api.libs.json.JsString
  import play.api.libs.json.Writes
  import play.api.libs.functional.syntax._
  import com.gilt.gilt.trest.v0.models.json._
  import com.gilt.public.api.models.json._

  private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

  private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
    def writes(x: java.util.UUID) = JsString(x.toString)
  }

  private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
    import org.joda.time.format.ISODateTimeFormat.dateTimeParser
    dateTimeParser.parseDateTime(str)
  }

  private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
    def writes(x: org.joda.time.DateTime) = {
      import org.joda.time.format.ISODateTimeFormat.dateTime
      val str = dateTime.print(x)
      JsString(str)
    }
  }

  implicit def jsonReadsGiltTrestError: play.api.libs.json.Reads[Error] = {
    (__ \ "error").read[String].map { x => new Error(error = x) }
  }

  implicit def jsonWritesGiltTrestError: play.api.libs.json.Writes[Error] = new play.api.libs.json.Writes[Error] {
    def writes(x: Error) = play.api.libs.json.Json.obj(
      "error" -> play.api.libs.json.Json.toJson(x.error)
    )
  }

  implicit def jsonReadsGiltTrestSale: play.api.libs.json.Reads[Sale] = {
    (__ \ "sales").read[Seq[com.gilt.public.api.models.SaleDetail]].map { x => new Sale(sales = x) }
  }

  implicit def jsonWritesGiltTrestSale: play.api.libs.json.Writes[Sale] = new play.api.libs.json.Writes[Sale] {
    def writes(x: Sale) = play.api.libs.json.Json.obj(
      "sales" -> play.api.libs.json.Json.toJson(x.sales)
    )
  }

  implicit def jsonReadsGiltTrestUser: play.api.libs.json.Reads[User] = {
    (
      (__ \ "username").read[String] and
        (__ \ "email").read[String]
      )(User.apply _)
  }

  implicit def jsonWritesGiltTrestUser: play.api.libs.json.Writes[User] = {
    (
      (__ \ "username").write[String] and
        (__ \ "email").write[String]
      )(unlift(User.unapply _))
  }

  implicit def jsonReadsGiltTrestUserForm: play.api.libs.json.Reads[UserForm] = {
    (__ \ "username").read[String].map { x => new UserForm(username = x) }
  }

  implicit def jsonWritesGiltTrestUserForm: play.api.libs.json.Writes[UserForm] = new play.api.libs.json.Writes[UserForm] {
    def writes(x: UserForm) = play.api.libs.json.Json.obj(
      "username" -> play.api.libs.json.Json.toJson(x.username)
    )
  }
}
}

package com.gilt.gilt.trest.v0 {

object Bindables {

  import play.api.mvc.{PathBindable, QueryStringBindable}
  import org.joda.time.{DateTime, LocalDate}
  import org.joda.time.format.ISODateTimeFormat
  import com.gilt.gilt.trest.v0.models._

  // Type: date-time-iso8601
  implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
    ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
  )

  implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
    ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
  )

  // Type: date-iso8601
  implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
    ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: Exception) => s"Error parsing date $key. Example: 2014-04-29"
  )

  implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
    ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: Exception) => s"Error parsing date $key. Example: 2014-04-29"
  )



}

}


package com.gilt.gilt.trest.v0 {

object Constants {

  val UserAgent = "apidoc:0.9.17 http://www.apidoc.me/gilt/gilt-trest/0.0.1-dev/play_2_3_client"
  val Version = "0.0.1-dev"
  val VersionMajor = 0

}

class Client(
              apiUrl: String,
              auth: scala.Option[com.gilt.gilt.trest.v0.Authorization] = None,
              defaultHeaders: Seq[(String, String)] = Nil
              ) {
  import com.gilt.gilt.trest.v0.models.json._
  import com.gilt.public.api.models.json._

  private val logger = play.api.Logger("com.gilt.gilt.trest.v0.Client")

  logger.info(s"Initializing com.gilt.gilt.trest.v0.Client for url $apiUrl")

  def sales: Sales = Sales

  def users: Users = Users

  object Sales extends Sales {
    override def getPinned()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.Sale] = {
      _executeRequest("GET", s"/sales/pinned").map {
        case r if r.status == 200 => _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.gilt.trest.v0.models.Sale", r, _.validate[com.gilt.gilt.trest.v0.models.Sale])
        case r => throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }

    override def getByStore(
                             store: String
                             )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.Sale] = {
      _executeRequest("GET", s"/sales/${play.utils.UriEncoding.encodePathSegment(store, "UTF-8")}").map {
        case r if r.status == 200 => _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.gilt.trest.v0.models.Sale", r, _.validate[com.gilt.gilt.trest.v0.models.Sale])
        case r => throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }

    override def postPinBySaleKey(
                                   saleKey: String
                                   )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.public.api.models.SaleDetail] = {
      _executeRequest("POST", s"/sales/${play.utils.UriEncoding.encodePathSegment(saleKey, "UTF-8")}/pin").map {
        case r if r.status == 200 => _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.public.api.models.SaleDetail", r, _.validate[com.gilt.public.api.models.SaleDetail])
        case r => throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200")
      }
    }
  }

  object Users extends Users {
    override def postRegister(
                               user: com.gilt.gilt.trest.v0.models.User
                               )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.User] = {
      val payload = play.api.libs.json.Json.toJson(user)

      _executeRequest("POST", s"/users/register", body = Some(payload)).map {
        case r if r.status == 201 => _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.gilt.trest.v0.models.User", r, _.validate[com.gilt.gilt.trest.v0.models.User])
        case r => throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201")
      }
    }

    override def postLogin(
                            userForm: com.gilt.gilt.trest.v0.models.UserForm
                            )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.User] = {
      val payload = play.api.libs.json.Json.toJson(userForm)

      _executeRequest("POST", s"/users/login", body = Some(payload)).map {
        case r if r.status == 200 => _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.gilt.trest.v0.models.User", r, _.validate[com.gilt.gilt.trest.v0.models.User])
        case r if r.status == 404 => throw new com.gilt.gilt.trest.v0.errors.ErrorResponse(r)
        case r => throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
      }
    }
  }

  def _requestHolder(path: String): play.api.libs.ws.WSRequestHolder = {
    import play.api.Play.current

    val holder = play.api.libs.ws.WS.url(apiUrl + path).withHeaders(
      "User-Agent" -> Constants.UserAgent,
      "X-Apidoc-Version" -> Constants.Version,
      "X-Apidoc-Version-Major" -> Constants.VersionMajor.toString
    ).withHeaders(defaultHeaders : _*)
    auth.fold(holder) { a =>
      a match {
        case Authorization.Basic(username, password) => {
          holder.withAuth(username, password.getOrElse(""), play.api.libs.ws.WSAuthScheme.BASIC)
        }
        case _ => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }
    }
  }

  def _logRequest(method: String, req: play.api.libs.ws.WSRequestHolder)(implicit ec: scala.concurrent.ExecutionContext): play.api.libs.ws.WSRequestHolder = {
    val queryComponents = for {
      (name, values) <- req.queryString
      value <- values
    } yield name -> value
    val url = s"${req.url}${queryComponents.mkString("?", "&", "")}"
    auth.fold(logger.info(s"curl -X $method $url")) { _ =>
      logger.info(s"curl -X $method -u '[REDACTED]:' $url")
    }
    req
  }

  def _executeRequest(
                       method: String,
                       path: String,
                       queryParameters: Seq[(String, String)] = Seq.empty,
                       body: Option[play.api.libs.json.JsValue] = None
                       )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[play.api.libs.ws.WSResponse] = {
    method.toUpperCase match {
      case "GET" => {
        _logRequest("GET", _requestHolder(path).withQueryString(queryParameters:_*)).get()
      }
      case "POST" => {
        _logRequest("POST", _requestHolder(path).withQueryString(queryParameters:_*)).post(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "PUT" => {
        _logRequest("PUT", _requestHolder(path).withQueryString(queryParameters:_*)).put(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "PATCH" => {
        _logRequest("PATCH", _requestHolder(path).withQueryString(queryParameters:_*)).patch(body.getOrElse(play.api.libs.json.Json.obj()))
      }
      case "DELETE" => {
        _logRequest("DELETE", _requestHolder(path).withQueryString(queryParameters:_*)).delete()
      }
      case "HEAD" => {
        _logRequest("HEAD", _requestHolder(path).withQueryString(queryParameters:_*)).head()
      }
      case "OPTIONS" => {
        _logRequest("OPTIONS", _requestHolder(path).withQueryString(queryParameters:_*)).options()
      }
      case _ => {
        _logRequest(method, _requestHolder(path).withQueryString(queryParameters:_*))
        sys.error("Unsupported method[%s]".format(method))
      }
    }
  }

}

object Client {

  def parseJson[T](
                    className: String,
                    r: play.api.libs.ws.WSResponse,
                    f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
                    ): T = {
    f(play.api.libs.json.Json.parse(r.body)) match {
      case play.api.libs.json.JsSuccess(x, _) => x
      case play.api.libs.json.JsError(errors) => {
        throw new com.gilt.gilt.trest.v0.errors.FailedRequest(r.status, s"Invalid json for class[" + className + "]: " + errors.mkString(" "))
      }
    }
  }

}

sealed trait Authorization
object Authorization {
  case class Basic(username: String, password: Option[String] = None) extends Authorization
}

trait Sales {
  def getPinned()(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.Sale]

  def getByStore(
                  store: String
                  )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.Sale]

  def postPinBySaleKey(
                        saleKey: String
                        )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.public.api.models.SaleDetail]
}

trait Users {
  def postRegister(
                    user: com.gilt.gilt.trest.v0.models.User
                    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.User]

  def postLogin(
                 userForm: com.gilt.gilt.trest.v0.models.UserForm
                 )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[com.gilt.gilt.trest.v0.models.User]
}

package errors {

import com.gilt.gilt.trest.v0.models.json._
import com.gilt.public.api.models.json._

case class ErrorResponse(
                          response: play.api.libs.ws.WSResponse,
                          message: Option[String] = None
                          ) extends Exception(message.getOrElse(response.status + ": " + response.body)){
  lazy val error = _root_.com.gilt.gilt.trest.v0.Client.parseJson("com.gilt.gilt.trest.v0.models.Error", response, _.validate[com.gilt.gilt.trest.v0.models.Error])
}

case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None) extends Exception(s"HTTP $responseCode: $message")

}

}